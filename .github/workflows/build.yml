name: Build and Test

on:
  push:
    branches: [ main ]
  pull_request:
  release:
    types: [ published ]
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:

concurrency: 
  cancel-in-progress: true
  group: ${{ github.workflow }}-${{ github.ref }}

env:
  RUNNER_IDLE_TIMEOUT_MINUTES: 5
  RUNNER_MAX_RESTARTS: 1
  DOCKER_REPO: ghcr.io/${{ github.repository }}/runner
  DOCKER_RELEASE_PREFIX_OPT: ${{ github.event_name == 'release' && github.event.release.tag_name || '' }}${{ github.event_name == 'release' && '-' || '' }}

jobs:
  registration-token:
    name: Create Registration Token
    runs-on: ubuntu-latest
    environment: registration
    permissions:
      contents: read
    outputs:
      reg_token: ${{ steps.encoded-reg-token.outputs.out }}
    steps:
      - uses: actions/checkout@v4
      - name: Create registration token
        id: token
        shell: bash
        run: |
          if [ -z "${{ secrets.REGISTRATION_PAT }}" ]; then
            echo "REGISTRATION_PAT secret missing" >&2
            exit 1
          fi
          token=$(pwsh -Command ". ./registration.ps1; New-RegistrationToken -PatToken '${{ secrets.REGISTRATION_PAT }}' -RepoFullName '${{ github.repository }}'")
          echo "::add-mask::$token"
          if [ -z "$token" ]; then
            echo "Failed to create registration token" >&2
            exit 1
          fi
          echo "reg_token=$token" >> "$GITHUB_OUTPUT"

      - name: Encode registration token
        id: encoded-reg-token
        shell: pwsh
        env:
          SECRET: ${{ secrets.SYM_ENC }}
          IN: ${{ steps.token.outputs.reg_token }}
        run: |
          $plain = $env:IN
          if (-not $plain) { throw "IN payload missing" }
          $key = [System.Security.Cryptography.SHA256]::HashData([System.Text.Encoding]::UTF8.GetBytes($env:SECRET))
          $aes = [System.Security.Cryptography.Aes]::Create()
          $aes.Mode = 'CBC'
          $aes.Padding = 'PKCS7'
          $aes.Key = $key
          $aes.GenerateIV()
          $encryptor = $aes.CreateEncryptor()
          $plainBytes = [System.Text.Encoding]::UTF8.GetBytes($plain)
          $cipher = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)
          $payload = $aes.IV + $cipher
          $out = [Convert]::ToBase64String($payload)
          "out=$out" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

  build:
    name: Build and Launch Runners
    needs: registration-token
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            tag: ubuntu
            socket: "/var/run/docker.sock:/var/run/docker.sock"
          - os: ${{ github.run_attempt > 1 && 'windows-latest' || 'windows-runner-set' }}
            platform: windows
            tag: windows
            socket: "\\\\.\\pipe\\docker_engine:\\\\.\\pipe\\docker_engine"
    runs-on: ${{ matrix.os }}
    env:
      TEST_TAG: runner-${{ matrix.platform }}-local
      TEST_PROJECT: test-${{ github.run_id }}-${{ matrix.platform }}
      PLATFORMS: ${{ matrix.platform == 'linux' && 'linux/amd64,linux/arm64' || 'windows/amd64' }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Set up QEMU
        if: matrix.platform == 'linux'
        uses: docker/setup-qemu-action@v2
        with:
          platforms: ${{ env.PLATFORMS }}
      
      - name: Set up Docker Buildx
        if: matrix.platform == 'linux'
        uses: docker/setup-buildx-action@v3
        with:
          platforms: ${{ env.PLATFORMS }}

      - name: Build Multi-Arch Docker Image (using Buildx)
        if: matrix.platform == 'linux'
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.platform }}
          tags: ${{ env.TEST_TAG }}
          platforms: ${{ env.PLATFORMS }}
          cache-from: type=registry,ref=${{ env.DOCKER_REPO }}:buildcache-${{ matrix.platform }}
          cache-to: type=gha,mode=max
      
      - name: Load Docker Image (using Buildx)
        if: matrix.platform == 'linux'
        uses: docker/build-push-action@v6
        with:
          load: true
          context: ${{ matrix.platform }}
          tags: ${{ env.TEST_TAG }}
          cache-from: type=gha
      
      - name: Build Docker Image (without Buildx)
        if: matrix.platform == 'windows'
        run: |
          docker pull ${{ env.DOCKER_REPO }}:${{ matrix.tag }} || echo "No cache image found"
          docker build -t "${{ env.TEST_TAG }}" ${{ matrix.platform }}

      - name: Decode registration token
        id: decoded-reg-token
        shell: pwsh
        env:
          SECRET: ${{ secrets.SYM_ENC }}
          IN: ${{ needs.registration-token.outputs.reg_token }}
        run: |
          $payload = [Convert]::FromBase64String($env:IN)
          if ($payload.Length -lt 17) { throw "IN payload invalid" }
          $iv = $payload[0..15]
          $cipher = $payload[16..($payload.Length-1)]
          $key = [System.Security.Cryptography.SHA256]::HashData([System.Text.Encoding]::UTF8.GetBytes($env:SECRET))
          $aes = [System.Security.Cryptography.Aes]::Create()
          $aes.Mode = 'CBC'
          $aes.Padding = 'PKCS7'
          $aes.Key = $key
          $aes.IV = $iv
          $decryptor = $aes.CreateDecryptor()
          $plainBytes = $decryptor.TransformFinalBlock($cipher, 0, $cipher.Length)
          $plain = [System.Text.Encoding]::UTF8.GetString($plainBytes)
          Write-Output "::add-mask::$plain"
          "out=$plain" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Start runner via launch script
        shell: pwsh
        run: |
          $regToken = "${{ steps.decoded-reg-token.outputs.out }}"
          if (-not $regToken) { throw "REG_TOKEN missing" }
          . ./launch.ps1
          $labels = "self-hosted,${{ matrix.platform }},docker,run-${{ github.run_id }}"
          $repoObj = [pscustomobject]@{ full_name = "${{ github.repository }}"; html_url = "https://github.com/${{ github.repository }}" }
          Start-Runner -Repo $repoObj -RegToken $regToken -ComposeProject "${{ env.TEST_PROJECT }}" -Platform "${{ matrix.platform }}" -RunnerIdleTimeoutMinutes $env:RUNNER_IDLE_TIMEOUT_MINUTES -RunnerMaxRestarts $env:RUNNER_MAX_RESTARTS -RunnerLabels $labels -RunnerImage "${{ env.TEST_TAG }}" -RunnerName "${{ env.TEST_PROJECT }}" -WithWsl:$false

      - name: Ensure runner container is running
        shell: pwsh
        run: |
          $deadline = (Get-Date).AddMinutes(2)
          $state = $null
          $containerId = $null

          function Get-ContainerId {
              param([string]$Project)
              $id = docker ps --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              if (-not $id) {
                  $id = docker ps -a --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              }
              return $id
          }

          while ((Get-Date) -lt $deadline) {
              $containerId = Get-ContainerId -Project "${{ env.TEST_PROJECT }}"
              if (-not $containerId) {
                  Start-Sleep -Seconds 5
                  continue
              }

              $stateJson = docker inspect --format "{{json .State}}" $containerId 2>$null
              if ($LASTEXITCODE -ne 0 -or -not $stateJson) {
                  Start-Sleep -Seconds 5
                  continue
              }
              $state = $stateJson | ConvertFrom-Json
              if ($state.Running) {
                  Write-Host "✅ Runner container '$containerId' is running."
                  break
              }
              if ($state.Status -eq "exited") {
                  Write-Host "ℹ️ Container exited early. State: $(ConvertTo-Json $state -Compress)"
                  docker logs $containerId
                  throw "Runner container exited with code $($state.ExitCode)."
              }
              Start-Sleep -Seconds 5
          }
          if (-not $state -or -not $state.Running) {
              if ($state) { Write-Host "ℹ️ Final container state: $(ConvertTo-Json $state -Compress)" }
              if ($containerId) { docker logs $containerId }
              throw "Runner container for project '${{ env.TEST_PROJECT }}' did not reach running state before timeout."
          }

      - name: Check runner logs for readiness
        shell: pwsh
        run: |
          function Get-ContainerId {
              param([string]$Project)
              $id = docker ps --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              if (-not $id) {
                  $id = docker ps -a --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              }
              return $id
          }

          $containerId = Get-ContainerId -Project "${{ env.TEST_PROJECT }}"
          if (-not $containerId) { throw "No container found for project '${{ env.TEST_PROJECT }}'." }

          $deadline = (Get-Date).AddMinutes(2)
          $ready = $false
          while ((Get-Date) -lt $deadline) {
              $logs = docker logs $containerId 2>$null
              if ($logs -match "Listening for jobs") {
                  $ready = $true
                  break
              }
              Start-Sleep -Seconds 5
          }

          Write-Host "===== runner logs ($containerId) ====="
          docker logs $containerId
          Write-Host "======================================"

          if (-not $ready) {
              throw "Runner container '$containerId' did not log readiness ('Listening for jobs')."
          }

      - name: Wait for self-hosted jobs
        uses: yogeshlonkar/wait-for-jobs@v0.4.9
        with:
          jobs: "Integrated Runner Test (${{ matrix.platform }})"
          ignore-skipped: 'false'
          ttl: '2'

      - name: Push Docker Image (with Buildx)
        uses: docker/build-push-action@v6
        if: matrix.platform == 'linux' && (github.event_name == 'release' || github.event_name == 'push' || github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.ref_name == 'main'))
        with:
          push: true
          context: ${{ matrix.platform }}
          tags: "${{ env.DOCKER_REPO }}:${{ env.DOCKER_RELEASE_PREFIX_OPT }}${{ matrix.tag }}"
          platforms: ${{ env.PLATFORMS }}
          cache-from: type=gha
          cache-to: type=registry,ref=${{ env.DOCKER_REPO }}:buildcache-${{ matrix.platform }},mode=max
          
      - name: Push Docker Image (without Buildx)
        if: matrix.platform == 'windows' && (github.event_name == 'release' || github.event_name == 'push' || github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.ref_name == 'main'))
        env:
          RELEASE_TAG: "${{ env.DOCKER_REPO }}:${{ env.DOCKER_RELEASE_PREFIX_OPT }}${{ matrix.tag }}"
        run: |
          docker tag "${{ env.TEST_TAG }}" "${{ env.RELEASE_TAG }}"
          docker push "${{ env.RELEASE_TAG }}"

  cancel-on-failure:
    name: Cancel on Build Failure
    needs: build
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Cancel workflow
        uses: action-pack/cancel@v1

  test:
    name: Integrated Runner Test
    needs: registration-token
    environment: testing
    permissions:
      contents: none
    strategy:
      matrix:
        include:
          - platform: linux
          - platform: windows
    runs-on:
      - self-hosted
      - ${{ matrix.platform }}
      - run-${{ github.run_id }}
    timeout-minutes: 5
    steps:
      - run: echo "Self-hosted runner alive on ${{ matrix.platform }}"

  merge:
    name: Merge Manifest
    needs: [build, test]
    if: github.event_name == 'release' || github.event_name == 'push' || github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.ref_name == 'main')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      DOCKER_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || 'latest' }}
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Merge multi-platform images
        run: |
          docker buildx imagetools create \
            -t ${{ env.DOCKER_REPO }}:${{ env.DOCKER_TAG }} \
            ${{ env.DOCKER_REPO }}:${{ env.DOCKER_RELEASE_PREFIX_OPT }}ubuntu \
            ${{ env.DOCKER_REPO }}:${{ env.DOCKER_RELEASE_PREFIX_OPT }}windows

  merge-status:
    name: Merge Status Check
    needs: [merge]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: none
    outputs:
      merge_result: ${{ steps.check-status.outputs.result }}
    steps:
      - name: Check merge job status
        id: check-status
        run: |
          if [ "${{ needs.merge.result }}" = "failure" ]; then
            echo "result=failure" >> "$GITHUB_OUTPUT"
            exit 1
          else
            echo "result=${{ needs.merge.result }}" >> "$GITHUB_OUTPUT"
          fi

  complete:
    name: Complete Workflow
    needs: 
      - merge-status
      - cleanup-runners
      - build
    environment: completion
    runs-on: ubuntu-latest
    permissions:
      contents: none
    steps:
      - name: Workflow complete
        run: echo "Workflow has finished all jobs."

  cleanup-runners:
    name: Cleanup Runners
    needs: [build, test]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment: registration
    steps:
      - uses: actions/checkout@v4
      - name: Delete self-hosted runners for this run
        shell: pwsh
        env:
          PAT_TOKEN: ${{ secrets.REGISTRATION_PAT }}
          RUNNER_NAMES: "test-${{ github.run_id }}-linux,test-${{ github.run_id }}-windows"
          REPO_FULL_NAME: ${{ github.repository }}
        run: |
          if (-not $env:PAT_TOKEN) { throw "PAT_TOKEN (REGISTRATION_PAT) is required for cleanup." }
          ./cleanup-runners.ps1 -RepoFullName $env:REPO_FULL_NAME -PatToken $env:PAT_TOKEN -RunnerNames ($env:RUNNER_NAMES -split ",")
