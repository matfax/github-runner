name: Runner Build and Test

on:
  push:
    branches: [ main ]
  pull_request:
  release:
    types: [ published ]
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:
    inputs:
      use_fallback:
        description: 'Force use of GitHub-hosted runner?'
        type: boolean
        default: false

concurrency: 
  cancel-in-progress: true
  group: ${{ github.workflow }}-${{ github.ref }}

env:
  RUNNER_IDLE_TIMEOUT_MINUTES: 5
  RUNNER_MAX_RESTARTS: 1

jobs:
  watchdog:
    name: Timeout Watchdog
    if: ${{ !inputs.use_fallback }}
    runs-on: ubuntu-latest
    environment: watchdog-timer
    permissions:
      actions: write
      checks: read
    steps:
      - uses: actions/checkout@v4
      - name: Check for Stuck Jobs and Fallback
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Watchdog timer expired (5 minutes passed). Checking job status..."
          
          STUCK_JOBS=$(gh run view "${{ github.run_id }}" --json jobs --jq '
            .jobs[] 
            | select(.name | contains("Build")) 
            | select(.status == "queued" or .status == "waiting") 
            | .name')
          
          if [ -n "$STUCK_JOBS" ]; then
            echo "❌ Detected stuck jobs (Runner unavailable):"
            echo "$STUCK_JOBS"
            echo "-------------------------------------------"
            echo "Triggering fallback run on GitHub-hosted runners..."
            
            gh workflow run "${{ github.workflow }}" --ref "${{ github.ref_name }}" -f use_fallback=true
            
            echo "Cancelling this stuck run..."
            gh run cancel "${{ github.run_id }}"
            exit 1
          else
            echo "✅ All Build jobs are either running or completed. Self-hosted runner is active."
            exit 0
          fi

  registration-token:
    name: Create Registration Token
    runs-on: ubuntu-latest
    environment: registration
    permissions:
      contents: read
    outputs:
      reg_token: ${{ steps.encoded-reg-token.outputs.out }}
    steps:
      - uses: actions/checkout@v4
      - name: Create registration token
        id: token
        shell: bash
        run: |
          if [ -z "${{ secrets.REGISTRATION_PAT }}" ]; then
            echo "REGISTRATION_PAT secret missing" >&2
            exit 1
          fi
          token=$(pwsh -Command ". ./registration.ps1; New-RegistrationToken -PatToken '${{ secrets.REGISTRATION_PAT }}' -RepoFullName '${{ github.repository }}'")
          echo "::add-mask::$token"
          if [ -z "$token" ]; then
            echo "Failed to create registration token" >&2
            exit 1
          fi
          echo "reg_token=$token" >> "$GITHUB_OUTPUT"

      - name: Encode registration token
        id: encoded-reg-token
        shell: pwsh
        env:
          SECRET: ${{ secrets.SYM_ENC }}
          IN: ${{ steps.token.outputs.reg_token }}
        run: |
          $plain = $env:IN
          if (-not $plain) { throw "IN payload missing" }
          $key = [System.Security.Cryptography.SHA256]::HashData([System.Text.Encoding]::UTF8.GetBytes($env:SECRET))
          $aes = [System.Security.Cryptography.Aes]::Create()
          $aes.Mode = 'CBC'
          $aes.Padding = 'PKCS7'
          $aes.Key = $key
          $aes.GenerateIV()
          $encryptor = $aes.CreateEncryptor()
          $plainBytes = [System.Text.Encoding]::UTF8.GetBytes($plain)
          $cipher = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)
          $payload = $aes.IV + $cipher
          $out = [Convert]::ToBase64String($payload)
          "out=$out" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

  build:
    name: Build and Launch Runners
    needs: registration-token
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            socket: "/var/run/docker.sock:/var/run/docker.sock"
          - os: ${{ !inputs.use_fallback && 'windows-runner-set' || 'windows-latest' }}
            platform: windows
            socket: "\\\\.\\pipe\\docker_engine:\\\\.\\pipe\\docker_engine"
    runs-on: ${{ matrix.os }}
    env:
      DOCKER_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || 'latest' }}
      TEST_TAG: runner-${{ matrix.platform }}-local
      TEST_PROJECT: ${{ github.run_id }}-${{ matrix.platform }}
      PLATFORMS: ${{ matrix.platform == 'linux' && 'linux/amd64,linux/arm64' || 'windows/amd64' }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          # Windows runners use the Windows Docker daemon, so we need the
          # native builder instead of the container driver.
          driver: ${{ matrix.platform == 'linux' && 'docker-container' || 'docker' }}
          platforms: ${{ env.PLATFORMS }}
      
      - name: Build and export to Docker
        uses: docker/build-push-action@v6
        with:
          load: true
          context: ${{ matrix.platform }}
          tags: ${{ env.TEST_TAG }}

      - name: Decode registration token
        id: decoded-reg-token
        shell: pwsh
        env:
          SECRET: ${{ secrets.SYM_ENC }}
          IN: ${{ needs.registration-token.outputs.reg_token }}
        run: |
          $payload = [Convert]::FromBase64String($env:IN)
          if ($payload.Length -lt 17) { throw "IN payload invalid" }
          $iv = $payload[0..15]
          $cipher = $payload[16..($payload.Length-1)]
          $key = [System.Security.Cryptography.SHA256]::HashData([System.Text.Encoding]::UTF8.GetBytes($env:SECRET))
          $aes = [System.Security.Cryptography.Aes]::Create()
          $aes.Mode = 'CBC'
          $aes.Padding = 'PKCS7'
          $aes.Key = $key
          $aes.IV = $iv
          $decryptor = $aes.CreateDecryptor()
          $plainBytes = $decryptor.TransformFinalBlock($cipher, 0, $cipher.Length)
          $plain = [System.Text.Encoding]::UTF8.GetString($plainBytes)
          Write-Output "::add-mask::$plain"
          "out=$plain" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Start runner via launch script
        shell: pwsh
        run: |
          $regToken = "${{ steps.decoded-reg-token.outputs.out }}"
          if (-not $regToken) { throw "REG_TOKEN missing" }
          . ./launch.ps1
          $labels = "self-hosted,${{ matrix.platform }},docker,run-${{ github.run_id }}"
          $repoObj = [pscustomobject]@{ full_name = "${{ github.repository }}"; html_url = "https://github.com/${{ github.repository }}" }
          Start-Runner -Repo $repoObj -RegToken $regToken -ComposeProject "${{ env.TEST_PROJECT }}" -Platform "${{ matrix.platform }}" -RunnerIdleTimeoutMinutes $env:RUNNER_IDLE_TIMEOUT_MINUTES -RunnerMaxRestarts $env:RUNNER_MAX_RESTARTS -RunnerLabels $labels -RunnerImage "${{ env.TEST_TAG }}" -RunnerName "${{ env.TEST_PROJECT }}" -WithWsl:$false

      - name: Ensure runner container is running
        shell: pwsh
        run: |
          $deadline = (Get-Date).AddMinutes(2)
          $state = $null
          $containerId = $null

          function Get-ContainerId {
              param([string]$Project)
              $id = docker ps --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              if (-not $id) {
                  $id = docker ps -a --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              }
              return $id
          }

          while ((Get-Date) -lt $deadline) {
              $containerId = Get-ContainerId -Project "${{ env.TEST_PROJECT }}"
              if (-not $containerId) {
                  Start-Sleep -Seconds 5
                  continue
              }

              $stateJson = docker inspect --format "{{json .State}}" $containerId 2>$null
              if ($LASTEXITCODE -ne 0 -or -not $stateJson) {
                  Start-Sleep -Seconds 5
                  continue
              }
              $state = $stateJson | ConvertFrom-Json
              if ($state.Running) {
                  Write-Host "✅ Runner container '$containerId' is running."
                  break
              }
              if ($state.Status -eq "exited") {
                  Write-Host "ℹ️ Container exited early. State: $(ConvertTo-Json $state -Compress)"
                  docker logs $containerId
                  throw "Runner container exited with code $($state.ExitCode)."
              }
              Start-Sleep -Seconds 5
          }
          if (-not $state -or -not $state.Running) {
              if ($state) { Write-Host "ℹ️ Final container state: $(ConvertTo-Json $state -Compress)" }
              if ($containerId) { docker logs $containerId }
              throw "Runner container for project '${{ env.TEST_PROJECT }}' did not reach running state before timeout."
          }

      - name: Check runner logs for readiness
        shell: pwsh
        run: |
          function Get-ContainerId {
              param([string]$Project)
              $id = docker ps --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              if (-not $id) {
                  $id = docker ps -a --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              }
              return $id
          }

          $containerId = Get-ContainerId -Project "${{ env.TEST_PROJECT }}"
          if (-not $containerId) { throw "No container found for project '${{ env.TEST_PROJECT }}'." }

          $deadline = (Get-Date).AddMinutes(2)
          $ready = $false
          while ((Get-Date) -lt $deadline) {
              $logs = docker logs $containerId 2>$null
              if ($logs -match "Listening for jobs") {
                  $ready = $true
                  break
              }
              Start-Sleep -Seconds 5
          }

          Write-Host "===== runner logs ($containerId) ====="
          docker logs $containerId
          Write-Host "======================================"

          if (-not $ready) {
              throw "Runner container '$containerId' did not log readiness ('Listening for jobs')."
          }

      - name: Wait for self-hosted jobs
        uses: yogeshlonkar/wait-for-jobs@v0.4.9
        with:
          jobs: "Integrated Runner Test (${{ matrix.platform }})"
          ignore-skipped: 'false'
          ttl: '2'

      - name: Build and push
        uses: docker/build-push-action@v6
        if: github.event_name == 'release' || github.event_name == 'push' || github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.ref_name == 'main')
        env:
          RELEASE_TAG: ghcr.io/${{ github.repository }}/runner-${{ matrix.platform }}:${{ env.DOCKER_TAG }}
        with:
          push: true
          context: ${{ matrix.platform }}
          tags: ${{ env.RELEASE_TAG }}
          platforms: ${{ env.PLATFORMS }}

  cancel-on-failure:
    name: Cancel Fast
    needs: build
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Cancel workflow
        uses: action-pack/cancel@v1

  test:
    name: Integrated Runner Test
    needs: registration-token
    environment: testing
    permissions:
      contents: none
    strategy:
      matrix:
        include:
          - platform: linux
          - platform: windows
    runs-on:
      - self-hosted
      - ${{ matrix.platform }}
      - run-${{ github.run_id }}
    timeout-minutes: 5
    steps:
      - run: echo "Self-hosted runner alive on ${{ matrix.platform }}"

  completion:
    name: Completion
    needs: [build, test, cleanup-runners]
    runs-on: ubuntu-latest
    environment: completion
    permissions:
      contents: read
    steps:
      - run: echo "Build and test completed successfully"

  cleanup-runners:
    name: Cleanup Runners
    needs: [build, test]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment: registration
    steps:
      - uses: actions/checkout@v4
      - name: Delete self-hosted runners for this run
        shell: pwsh
        env:
          PAT_TOKEN: ${{ secrets.REGISTRATION_PAT }}
          RUNNER_NAMES: "ci-${{ github.run_id }}-linux,ci-${{ github.run_id }}-windows"
          REPO_FULL_NAME: ${{ github.repository }}
        run: |
          if (-not $env:PAT_TOKEN) { throw "PAT_TOKEN (REGISTRATION_PAT) is required for cleanup." }
          ./cleanup-runners.ps1 -RepoFullName $env:REPO_FULL_NAME -PatToken $env:PAT_TOKEN -RunnerNames ($env:RUNNER_NAMES -split ",")
