name: Runner Build and Test

on:
  push:
    branches: [ main ]
  pull_request:
  release:
    types: [ published ]
  schedule:
    - cron: "0 0 * * *"

concurrency: 
  cancel-in-progress: true
  group: ${{ github.workflow }}-${{ github.ref }}

env:
  RUNNER_IDLE_TIMEOUT_MINUTES: 5
  RUNNER_MAX_RESTARTS: 1

jobs:
  registration-token:
    name: Create Registration Token
    runs-on: ubuntu-latest
    environment: registration
    permissions:
      contents: read
    outputs:
      reg_token: ${{ steps.encoded-reg-token.outputs.out }}
    steps:
      - uses: actions/checkout@v4
      - name: Create registration token
        id: token
        shell: bash
        run: |
          if [ -z "${{ secrets.REGISTRATION_PAT }}" ]; then
            echo "REGISTRATION_PAT secret missing" >&2
            exit 1
          fi
          token=$(pwsh -Command ". ./registration.ps1; New-RegistrationToken -PatToken '${{ secrets.REGISTRATION_PAT }}' -RepoFullName '${{ github.repository }}'")
          echo "::add-mask::$token"
          if [ -z "$token" ]; then
            echo "Failed to create registration token" >&2
            exit 1
          fi
          echo "reg_token=$token" >> "$GITHUB_OUTPUT"

      - name: Encode registration token
        id: encoded-reg-token
        shell: pwsh
        env:
          SECRET: ${{ secrets.SYM_ENC }}
          IN: ${{ steps.token.outputs.reg_token }}
        run: |
          $plain = $env:IN
          if (-not $plain) { throw "IN payload missing" }
          $key = [System.Security.Cryptography.SHA256]::HashData([System.Text.Encoding]::UTF8.GetBytes($env:SECRET))
          $aes = [System.Security.Cryptography.Aes]::Create()
          $aes.Mode = 'CBC'
          $aes.Padding = 'PKCS7'
          $aes.Key = $key
          $aes.GenerateIV()
          $encryptor = $aes.CreateEncryptor()
          $plainBytes = [System.Text.Encoding]::UTF8.GetBytes($plain)
          $cipher = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)
          $payload = $aes.IV + $cipher
          $out = [Convert]::ToBase64String($payload)
          "out=$out" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

  build:
    name: Build and Launch Runners
    needs: registration-token
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: ubuntu-latest
            name: linux
            dockerfile: linux/Dockerfile
            platform: linux
            socket: "/var/run/docker.sock:/var/run/docker.sock"
          - os: windows-latest
            name: windows
            dockerfile: windows/Dockerfile
            platform: windows
            socket: "\\\\.\\pipe\\docker_engine:\\\\.\\pipe\\docker_engine"
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Build image
        shell: pwsh
        run: |
          docker build -f ${{ matrix.dockerfile }} -t "runner-${{ matrix.name }}-local" .

      - name: Decode registration token
        id: decoded-reg-token
        shell: pwsh
        env:
          SECRET: ${{ secrets.SYM_ENC }}
          IN: ${{ needs.registration-token.outputs.reg_token }}
        run: |
          $payload = [Convert]::FromBase64String($env:IN)
          if ($payload.Length -lt 17) { throw "IN payload invalid" }
          $iv = $payload[0..15]
          $cipher = $payload[16..($payload.Length-1)]
          $key = [System.Security.Cryptography.SHA256]::HashData([System.Text.Encoding]::UTF8.GetBytes($env:SECRET))
          $aes = [System.Security.Cryptography.Aes]::Create()
          $aes.Mode = 'CBC'
          $aes.Padding = 'PKCS7'
          $aes.Key = $key
          $aes.IV = $iv
          $decryptor = $aes.CreateDecryptor()
          $plainBytes = $decryptor.TransformFinalBlock($cipher, 0, $cipher.Length)
          $plain = [System.Text.Encoding]::UTF8.GetString($plainBytes)
          Write-Output "::add-mask::$plain"
          "out=$plain" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Start runner via launch script
        shell: pwsh
        run: |
          $regToken = "${{ steps.decoded-reg-token.outputs.out }}"
          if (-not $regToken) { throw "REG_TOKEN missing" }
          . ./launch.ps1
          $labels = "self-hosted,${{ matrix.platform }},docker,run-${{ github.run_id }}"
          $composeProject = "ci-${{ github.run_id }}-${{ matrix.name }}"
          $repoObj = [pscustomobject]@{ full_name = "${{ github.repository }}"; html_url = "https://github.com/${{ github.repository }}" }
          Start-Runner -Repo $repoObj -RegToken $regToken -ComposeProject $composeProject -Platform "${{ matrix.platform }}" -RunnerIdleTimeoutMinutes $env:RUNNER_IDLE_TIMEOUT_MINUTES -RunnerMaxRestarts $env:RUNNER_MAX_RESTARTS -RunnerLabels $labels -RunnerImage "runner-${{ matrix.name }}-local" -RunnerName $composeProject -WithWsl:$false

      - name: Ensure runner container is running
        shell: pwsh
        run: |
          $composeProject = "ci-${{ github.run_id }}-${{ matrix.name }}"
          $deadline = (Get-Date).AddMinutes(2)
          $state = $null
          $containerId = $null

          function Get-ContainerId {
              param([string]$Project)
              $id = docker ps --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              if (-not $id) {
                  $id = docker ps -a --filter "label=com.docker.compose.project=$Project" --format "{{.ID}}" | Select-Object -First 1
              }
              return $id
          }

          while ((Get-Date) -lt $deadline) {
              $containerId = Get-ContainerId -Project $composeProject
              if (-not $containerId) {
                  Start-Sleep -Seconds 5
                  continue
              }

              $inspect = docker inspect $containerId 2>$null
              if ($LASTEXITCODE -ne 0 -or -not $inspect) {
                  Start-Sleep -Seconds 5
                  continue
              }
              $state = (ConvertFrom-Json $inspect)[0].State
              if ($state.Running) {
                  Write-Host "✅ Runner container '$containerId' is running."
                  break
              }
              if ($state.Status -eq "exited") {
                  Write-Host "ℹ️ Container exited early. State: $(ConvertTo-Json $state -Compress)"
                  docker logs $containerId
                  throw "Runner container exited with code $($state.ExitCode)."
              }
              Start-Sleep -Seconds 5
          }
          if (-not $state -or -not $state.Running) {
              if ($state) { Write-Host "ℹ️ Final container state: $(ConvertTo-Json $state -Compress)" }
              if ($containerId) { docker logs $containerId }
              throw "Runner container for project '$composeProject' did not reach running state before timeout."
          }

      - name: Wait for self-hosted jobs
        uses: yogeshlonkar/wait-for-jobs@v0.4.9
        with:
          jobs: "Test Runner Integration (${{ matrix.platform }})"
          ignore-skipped: 'false'
          ttl: '2'

      - name: Push image
        if: github.event_name == 'push' || github.event_name == 'schedule' || github.event_name == 'release'
        shell: pwsh
        run: |
          $tag = "${{ github.event_name == 'release' && github.event.release.tag_name || 'latest' }}"
          docker tag "runner-${{ matrix.name }}-local" "ghcr.io/${{ github.repository }}/runner-${{ matrix.name }}:$tag"
          docker push "ghcr.io/${{ github.repository }}/runner-${{ matrix.name }}:$tag"

  cancel-on-failure:
    name: Cancel Workflow on Build Failure
    needs: build
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Cancel workflow
        uses: action-pack/cancel@v1

  selfhost:
    name: Test Runner Integration
    needs: registration-token
    environment: testing
    permissions:
      contents: none
    strategy:
      matrix:
        include:
          - platform: linux
          - platform: windows
    runs-on:
      - self-hosted
      - ${{ matrix.platform }}
      - run-${{ github.run_id }}
    timeout-minutes: 5
    steps:
      - run: echo "Self-hosted runner alive on ${{ matrix.platform }}"

  completion:
    name: Completion
    needs: [build, selfhost, cleanup-runners]
    runs-on: ubuntu-latest
    environment: completion
    permissions:
      contents: read
    steps:
      - run: echo "Build and test completed successfully"

  cleanup-runners:
    name: Cleanup Runners
    needs: [build, selfhost]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    environment: registration
    steps:
      - uses: actions/checkout@v4
      - name: Delete self-hosted runners for this run
        shell: pwsh
        env:
          PAT_TOKEN: ${{ secrets.REGISTRATION_PAT }}
          RUNNER_NAMES: "ci-${{ github.run_id }}-linux,ci-${{ github.run_id }}-windows"
          REPO_FULL_NAME: ${{ github.repository }}
        run: |
          if (-not $env:PAT_TOKEN) { throw "PAT_TOKEN (REGISTRATION_PAT) is required for cleanup." }
          ./cleanup-runners.ps1 -RepoFullName $env:REPO_FULL_NAME -PatToken $env:PAT_TOKEN -RunnerNames ($env:RUNNER_NAMES -split ",")
