{{- $serviceFullName := include "docker-dind.fullname" . -}}
{{- $servicePort := .Values.service.port -}}

Windows Docker-in-Docker service installed!

To use this Docker daemon from your applications:

1. Set the DOCKER_HOST environment variable:

   PowerShell:
   $env:DOCKER_HOST = "tcp://{{ $serviceFullName }}:{{ $servicePort }}"

   Or in a Kubernetes pod spec:
   env:
     - name: DOCKER_HOST
       value: "tcp://{{ $serviceFullName }}.{{ .Release.Namespace }}.svc.cluster.local:{{ $servicePort }}"

2. Test the connection:

   docker version

3. Use Docker normally:

   docker run --rm hello-world
   docker build -t myapp:tag .

Service Details:
- Service: {{ $serviceFullName }}
- Namespace: {{ .Release.Namespace }}
- Type: {{ .Values.service.type }}
{{- if .Values.service.clusterIP }}
- ClusterIP: {{ .Values.service.clusterIP }}{{- if eq .Values.service.clusterIP "None" }} (Headless - resolves to node IP){{- end }}
{{- end }}
- Port: {{ $servicePort }}
- FQDN: {{ $serviceFullName }}.{{ .Release.Namespace }}.svc.cluster.local

{{- if eq .Values.service.type "ClusterIP" }}
Note: Service is ClusterIP. Ensure your Docker client is running within the cluster or has network access.
{{- end }}

{{- if .Values.persistence.enabled }}
Docker data will be persisted at: {{ .Values.persistence.mountPath }}
{{- else }}
Docker data is ephemeral and will be lost on pod restart.
{{- end }}
